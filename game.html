<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Game - Sarah Eck</title>
    <meta name="author" content="Sarah Eck">
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="css/effects.css">
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
</head>
<body>
    <!-- Navigation -->
    <nav class="navbar" role="navigation" aria-label="Main navigation">
        <div class="nav-container">
            <h1>Sarah Eck</h1>
            <button class="hamburger" aria-label="Toggle navigation menu">
                <i class="fas fa-bars"></i>
            </button>
            <ul class="nav-links">
                <li><a href="index.html">Home</a></li>
                <li><a href="hobbies.html">Hobbies</a></li>
                <li><a href="discover.html">Discover UMD</a></li>
                <li><a href="resume.html">Resume</a></li>
                <li><a href="career.html">Career</a></li>
                <li><a href="game.html">Interactive Game</a></li>
            </ul>
        </div>
    </nav>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maze Game - Find Your Way Out!</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        :root {
            --primary-color: #cc8672;
            --accent-color: #F8BBD9;
            --success-color: #4b3935;
            --warning-color: #F06292;
            --text-color: #4b3935;
            --background-color: #e8c3c3f2;
            --wall-color: #cc8672;
            --path-color: #caadda;
            --player-color: #E91E63;
            --start-color: #702845;
            --end-color: #F06292;
            --flower-pink: #F8BBD9;
            --deep-pink: #cc8672;
            --light-pink: #FCE4EC;
            --rose-pink: #E91E63;
            --blush-pink: #F8BBD9;
        }


        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }


        body {
            font-family: 'Segoe UI', arial, sans-serif;
            background: #cc8672;
            min-height: 100vh;
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            position: relative;
            overflow-x: hidden;
        }


        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image:
                radial-gradient(circle at 20% 20%, rgba(248, 187, 217, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(233, 30, 99, 0.2) 0%, transparent 50%),
                radial-gradient(circle at 40% 60%, rgba(194, 24, 91, 0.2) 0%, transparent 50%);
            pointer-events: none;
            z-index: -1;
        }


        .game-container {
            margin-top: 100px;
            background: var(--background-color);
            border-radius: 25px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(233, 30, 99, 0.2),
                        inset 0 0 20px rgba(248, 187, 217, 0.3);
            max-width: 1000px;
            width: 100%;
            text-align: center;
            border: 3px solid var(--accent-color);
            position: relative;
            overflow: hidden;
        }


        .game-container::before {
            content: '';
            position: absolute;
            top: -50px;
            right: -50px;
            width: 100px;
            height: 100px;
            background: radial-gradient(circle, var(--flower-pink) 30%, transparent 70%);
            border-radius: 50%;
            opacity: 0.6;
        }


        .game-container::after {
            content: '';
            position: absolute;
            bottom: -30px;
            left: -30px;
            width: 60px;
            height: 60px;
            background: radial-gradient(circle, var(--rose-pink) 40%, transparent 70%);
            border-radius: 50%;
            opacity: 0.4;
        }


        .game-header {
            margin-bottom: 20px;
        }


        .game-title {
            font-size: 2.5rem;
            color: var(--text-color);
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
            position: relative;
        }


        .game-title::before {
            content: 'üå∏';
            position: absolute;
            left: -40px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 1.5rem;
            animation: float 3s ease-in-out infinite;
        }


        .game-title::after {
            content: 'üå∫';
            position: absolute;
            right: -40px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 1.5rem;
            animation: float 3s ease-in-out infinite reverse;
        }


        @keyframes float {
            0%, 100% { transform: translateY(-50%) rotate(0deg); }
            50% { transform: translateY(-60%) rotate(10deg); }
        }


        .game-subtitle {
            color:var(--text-color);
            font-size: 1.1rem;
            margin-bottom: 20px;
        }


        .game-stats {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }


        .stat {
            background: linear-gradient(45deg, var(--accent-color), var(--primary-color));
            color: white;
            padding: 10px 20px;
            border-radius: 25px;
            font-weight: bold;
            min-width: 120px;
        }


        .maze-container {
            display: flex;
            justify-content: center;
            margin: 20px 0;
        }


        #mazeCanvas {
            border: 4px solid var(--wall-color);
            border-radius: 10px;
            background: var(--path-color);
            cursor: crosshair;
        }


        .controls {
            margin: 20px 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }


        .control-buttons {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }


        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 25px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }


        .btn-primary {
            background: color var(--accent-color);
            color: white;
        }

        .btn-done {
            background: color var(--accent-color);
            color: black;
        }

        .btn-success {
             background: color var(--accent-color);
            color: white;
        }


        .btn-warning {
             background: color var(--accent-color);
            color: white;
        }
        .btn-accent {
             background: color var(--accent-color);
            color: white;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }


        .btn:active {
            transform: translateY(0);
        }


        .instructions {
            background: linear-gradient(145deg, #FCE4EC 0%, #F8BBD9 100%);
            padding: 20px;
            border-radius: 15px;
            margin: 20px 0;
            border-left: 5px solid var(--accent-color);
            position: relative;
            overflow: hidden;
        }


        .instructions::before {
            content: 'üå∏ üå∫ üå∏ üå∫ üå∏';
            position: absolute;
            top: -10px;
            left: 0;
            right: 0;
            text-align: center;
            font-size: 1.2rem;
            opacity: 0.6;
            animation: float 4s ease-in-out infinite;
        }


        .instructions h3 {
            color: var(--primary-color);
            margin-bottom: 10px;
            margin-top: 20px;
        }


        .instructions p {
            margin: 5px 0;
            color: var(--text-color);
            font-weight: 500;
        }


        .difficulty-selector {
            margin: 20px 0;
        }


        .difficulty-selector label {
            margin-right: 15px;
            font-weight: bold;
            color: var(--text-color);
            
        }


        .difficulty-selector select {
            padding: 8px 15px;
            border: 2px solid var(--accent-color);
            border-radius: 20px;
            background:var(--accent-color);
            font-size: 1rem;
            cursor: pointer;
             font-family: 'Comic Sans MS', 'Segoe UI', system-ui, cursive;
        }


        .game-over {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }


        .game-over-content {
            background: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            max-width: 400px;
            width: 90%;
        }


        .game-over h2 {
            color: var(--success-color);
            font-size: 2rem;
            margin-bottom: 20px;
        }


        .final-stats {
            margin: 20px 0;
            font-size: 1.2rem;
        }


        .final-stats div {
            margin: 10px 0;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 10px;
        }


        /* Footer Styles */
        .footer {
            background-color: var(--secondary-bg);
            padding: 2rem 0;
            margin-top: 4rem;
            width: 100%;
        }

        .footer-content {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 2rem;
            text-align: center;
        }

        @media (max-width: 768px) {
            .game-container {
                padding: 20px;
            }

            .game-title {
                font-size: 2rem;
            }

            .game-stats {
                gap: 15px;
            }

            .stat {
                min-width: 100px;
                padding: 8px 16px;
            }

            .control-buttons {
                flex-direction: column;
                align-items: center;
            }

            .btn {
                width: 200px;
            }

            .footer {
                padding: 1.5rem 0;
                margin-top: 3rem;
            }
        }
    </style>
</head>
<body>
    <div class="floating-shapes"></div>
    <!-- Audio Elements -->
    <audio id="backgroundMusic" loop>
        <source src="audio/withyou.mp3" type="audio/mpeg">
    </audio>
    <audio id="victorySound">
        <source src="audio/magicchime.mp3" type="audio/mpeg">
    </audio>

    <div class="game-container">
        <div class="game-header">
            <h1 class="game-title">üéÆ Maze Adventure</h1>
            <p class="game-subtitle">Navigate through the maze and reach the exit!</p>
        </div>


        <div class="game-stats">
            <div class="stat">
                <i class="fas fa-clock"></i> Time: <span id="timer">00:00</span>
            </div>
            <div class="stat">
                <i class="fas fa-route"></i> Moves: <span id="moves">0</span>
            </div>
            <div class="stat">
                <i class="fas fa-trophy"></i> Level: <span id="level">1</span>
            </div>
        </div>


        <div class="difficulty-selector">
            <label for="difficulty">Difficulty:</label>
            <select id="difficulty">
                <option value="easy">Easy (15x15)</option>
                <option value="medium" selected>Medium (20x20)</option>
                <option value="hard">Hard (25x25)</option>
                <option value="expert">Expert (30x30)</option>
            </select>
        </div>


        <div class="maze-container">
            <canvas id="mazeCanvas" width="600" height="600"></canvas>
        </div>


        <div class="controls">
            <div class="control-buttons">
                <button class="btn btn-primary" id="newGameBtn">
                    <i class="fas fa-play"></i> New Game
                </button>
                <button class="btn btn-warning" id="pauseBtn">
                    <i class="fas fa-pause"></i> Pause
                </button>
                <button class="btn btn-accent" id="hintBtn">
                    <i class="fas fa-lightbulb"></i> Hint
                </button>
            </div>
        </div>


        <div class="instructions">
            <h3><i class="fas fa-info-circle"></i> How to Play</h3>
                <p><strong>üå∏ Goal:</strong> Guide your flower through the pink maze to reach the beautiful exit flower!</p>
                <p><strong>üéÆ Controls:</strong> Use WASD or Arrow Keys to move your flower</p>
                <p><strong>üì± Mobile:</strong> Swipe in the direction you want to move</p>
                <p><strong>üå∫ Challenge:</strong> Complete the floral maze in the shortest time with fewest moves!</p>
                <p><strong>üíê Bonus:</strong> Discover hidden flowers scattered throughout the paths!</p>
        </div>
    </div>


    <div class="game-over" id="gameOver">
        <div class="game-over-content">
            <h2 id="gameOverTitle">üå∏ Congratulations! üå∏</h2>
            <p style="color: var(--primary-color); margin-bottom: 20px;">You've successfully navigated through the floral maze!</p>
            <div class="final-stats">
                <div>‚è∞ Time: <span id="finalTime">00:00</span></div>
                <div>üå∫ Moves: <span id="finalMoves">0</span></div>
                <div>üèÜ Level: <span id="finalLevel">1</span></div>
            </div>
            <button class="btn btn-done" id="playAgainBtn">
                <i class="fas fa-redo"></i> Play Again
            </button>
        </div>
    </div>

    <!-- Footer -->
    <footer class="footer">
        <div class="footer-content">
            <p>&copy; 2025 Sarah Eck. All rights reserved.</p>
        </div>
    </footer>

   
    <script>
        // Initialize hamburger menu
        document.querySelector('.hamburger').addEventListener('click', function() {
            document.querySelector('.nav-links').classList.toggle('active');
        });

        class MazeGame {
            constructor() {
                this.canvas = document.getElementById('mazeCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.cellSize = 20;
                this.maze = [];
                this.player = { x: 1, y: 1 };
                this.start = { x: 1, y: 1 };
                this.end = { x: 0, y: 0 };
                this.moves = 0;
                this.startTime = null;
                this.gameRunning = false;
                this.gamePaused = false;
                this.timerInterval = null;
                this.difficulty = 'medium';
               
                this.difficulties = {
                    easy: { size: 15, cellSize: 30 },
                    medium: { size: 20, cellSize: 25 },
                    hard: { size: 25, cellSize: 20 },
                    expert: { size: 30, cellSize: 18 }
                };


                this.initializeEventListeners();
                this.generateMaze();
            }


            initializeEventListeners() {
                // Keyboard controls
                document.addEventListener('keydown', (e) => {
                    if (!this.gameRunning || this.gamePaused) return;
                   
                    const directions = {
                        'ArrowUp': { x: 0, y: -1 },
                        'ArrowDown': { x: 0, y: 1 },
                        'ArrowLeft': { x: -1, y: 0 },
                        'ArrowRight': { x: 1, y: 0 },
                        'w': { x: 0, y: -1 },
                        's': { x: 0, y: 1 },
                        'a': { x: -1, y: 0 },
                        'd': { x: 1, y: 0 }
                    };


                    if (directions[e.key]) {
                        e.preventDefault();
                        this.movePlayer(directions[e.key]);
                    }
                });


                // Button controls
                document.getElementById('newGameBtn').addEventListener('click', () => this.newGame());
                document.getElementById('pauseBtn').addEventListener('click', () => this.togglePause());
                document.getElementById('hintBtn').addEventListener('click', () => this.showHint());
                document.getElementById('playAgainBtn').addEventListener('click', () => {
                    // Stop victory sound if it's still playing
                    const victorySound = document.getElementById('victorySound');
                    victorySound.pause();
                    victorySound.currentTime = 0;
                    this.newGame();
                });
                document.getElementById('difficulty').addEventListener('change', (e) => {
                    this.difficulty = e.target.value;
                    this.newGame();
                });


                // Touch controls for mobile
                this.setupTouchControls();
            }


            setupTouchControls() {
                let touchStartX = 0;
                let touchStartY = 0;


                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    touchStartX = touch.clientX;
                    touchStartY = touch.clientY;
                });


                this.canvas.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    if (!this.gameRunning || this.gamePaused) return;


                    const touch = e.changedTouches[0];
                    const deltaX = touch.clientX - touchStartX;
                    const deltaY = touch.clientY - touchStartY;
                    const minSwipeDistance = 30;


                    if (Math.abs(deltaX) > Math.abs(deltaY)) {
                        // Horizontal swipe
                        if (Math.abs(deltaX) > minSwipeDistance) {
                            this.movePlayer(deltaX > 0 ? { x: 1, y: 0 } : { x: -1, y: 0 });
                        }
                    } else {
                        // Vertical swipe
                        if (Math.abs(deltaY) > minSwipeDistance) {
                            this.movePlayer(deltaY > 0 ? { x: 0, y: 1 } : { x: 0, y: -1 });
                        }
                    }
                });
            }


            generateMaze() {
                const config = this.difficulties[this.difficulty];
                this.cellSize = config.cellSize;
                const size = config.size;
               
                // Ensure odd dimensions for proper maze generation
                const mazeWidth = size % 2 === 0 ? size + 1 : size;
                const mazeHeight = size % 2 === 0 ? size + 1 : size;
               
                this.maze = Array(mazeHeight).fill().map(() => Array(mazeWidth).fill(1));
               
                // Generate maze using recursive backtracking
                this.carvePath(1, 1);
               
                // Set start and end points
                this.start = { x: 1, y: 1 };
                this.end = { x: mazeWidth - 2, y: mazeHeight - 2 };
                this.player = { ...this.start };
               
                // Update canvas size
                this.canvas.width = mazeWidth * this.cellSize;
                this.canvas.height = mazeHeight * this.cellSize;
               
                this.drawMaze();
            }


            carvePath(x, y) {
                this.maze[y][x] = 0; // Mark as path
               
                const directions = [
                    { x: 0, y: -2 }, // Up
                    { x: 2, y: 0 },  // Right
                    { x: 0, y: 2 },  // Down
                    { x: -2, y: 0 }  // Left
                ];
               
                // Shuffle directions
                for (let i = directions.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [directions[i], directions[j]] = [directions[j], directions[i]];
                }
               
                for (const dir of directions) {
                    const newX = x + dir.x;
                    const newY = y + dir.y;
                   
                    if (newX > 0 && newX < this.maze[0].length - 1 &&
                        newY > 0 && newY < this.maze.length - 1 &&
                        this.maze[newY][newX] === 1) {
                       
                        // Carve wall between current and new cell
                        this.maze[y + dir.y / 2][x + dir.x / 2] = 0;
                        this.carvePath(newX, newY);
                    }
                }
            }


            drawMaze() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
               
                // Draw background with subtle pink gradient
                const gradient = this.ctx.createLinearGradient(0, 0, this.canvas.width, this.canvas.height);
                gradient.addColorStop(0, '#FCE4EC');
                gradient.addColorStop(1, '#F8BBD9');
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
               
                for (let y = 0; y < this.maze.length; y++) {
                    for (let x = 0; x < this.maze[y].length; x++) {
                        if (this.maze[y][x] === 1) {
                            // Draw wall with pink gradient
                            const wallGradient = this.ctx.createLinearGradient(
                                x * this.cellSize, y * this.cellSize,
                                (x + 1) * this.cellSize, (y + 1) * this.cellSize
                            );
                            wallGradient.addColorStop(0, '#AD1457');
                            wallGradient.addColorStop(0.5, '#C2185B');
                            wallGradient.addColorStop(1, '#E91E63');
                           
                            this.ctx.fillStyle = wallGradient;
                            this.ctx.fillRect(x * this.cellSize, y * this.cellSize, this.cellSize, this.cellSize);
                           
                            // Add flower pattern to walls
                            this.drawFlowerPattern(x, y);
                        } else {
                            // Draw path with light pink
                            this.ctx.fillStyle = '#caadda';
                            this.ctx.fillRect(x * this.cellSize, y * this.cellSize, this.cellSize, this.cellSize);
                           
                            // Add occasional small flowers to paths
                            if (Math.random() < 0.1) {
                                this.drawSmallFlower(x, y);
                            }
                        }
                    }
                }
               
                // Draw start point with flower
                this.ctx.fillStyle = '#C2185B';
                this.ctx.fillRect(
                    this.start.x * this.cellSize + 2,
                    this.start.y * this.cellSize + 2,
                    this.cellSize - 4,
                    this.cellSize - 4
                );
                this.drawStartFlower(this.start.x, this.start.y);
               
                // Draw end point with flower
                this.ctx.fillStyle = '#F06292';
                this.ctx.fillRect(
                    this.end.x * this.cellSize + 2,
                    this.end.y * this.cellSize + 2,
                    this.cellSize - 4,
                    this.cellSize - 4
                );
                this.drawEndFlower(this.end.x, this.end.y);
               
                // Draw player as a flower
                this.drawPlayerFlower(this.player.x, this.player.y);
            }


            drawFlowerPattern(x, y) {
                const centerX = x * this.cellSize + this.cellSize / 2;
                const centerY = y * this.cellSize + this.cellSize / 2;
                const radius = this.cellSize / 6;
               
                // Draw small decorative flowers on walls
                this.ctx.fillStyle = '#F8BBD9';
                this.ctx.beginPath();
                this.ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                this.ctx.fill();
               
                // Draw petals
                this.ctx.fillStyle = '#E91E63';
                for (let i = 0; i < 5; i++) {
                    const angle = (i * 2 * Math.PI) / 5;
                    const petalX = centerX + Math.cos(angle) * radius * 1.5;
                    const petalY = centerY + Math.sin(angle) * radius * 1.5;
                    this.ctx.beginPath();
                    this.ctx.arc(petalX, petalY, radius * 0.6, 0, 2 * Math.PI);
                    this.ctx.fill();
                }
            }


            drawSmallFlower(x, y) {
                const centerX = x * this.cellSize + this.cellSize / 2;
                const centerY = y * this.cellSize + this.cellSize / 2;
                const radius = this.cellSize / 8;
               
                // Draw small flower center
                this.ctx.fillStyle = '#F06292';
                this.ctx.beginPath();
                this.ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                this.ctx.fill();
               
                // Draw small petals
                this.ctx.fillStyle = '#F8BBD9';
                for (let i = 0; i < 4; i++) {
                    const angle = (i * Math.PI) / 2;
                    const petalX = centerX + Math.cos(angle) * radius * 1.8;
                    const petalY = centerY + Math.sin(angle) * radius * 1.8;
                    this.ctx.beginPath();
                    this.ctx.arc(petalX, petalY, radius * 0.7, 0, 2 * Math.PI);
                    this.ctx.fill();
                }
            }


            drawStartFlower(x, y) {
                const centerX = x * this.cellSize + this.cellSize / 2;
                const centerY = y * this.cellSize + this.cellSize / 2;
                const radius = this.cellSize / 4;
               
                // Draw start flower
                this.ctx.fillStyle = '#FFFFFF';
                this.ctx.beginPath();
                this.ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                this.ctx.fill();
               
                // Draw petals
                this.ctx.fillStyle = '#C2185B';
                for (let i = 0; i < 6; i++) {
                    const angle = (i * Math.PI) / 3;
                    const petalX = centerX + Math.cos(angle) * radius * 1.3;
                    const petalY = centerY + Math.sin(angle) * radius * 1.3;
                    this.ctx.beginPath();
                    this.ctx.arc(petalX, petalY, radius * 0.8, 0, 2 * Math.PI);
                    this.ctx.fill();
                }
            }


            drawEndFlower(x, y) {
                const centerX = x * this.cellSize + this.cellSize / 2;
                const centerY = y * this.cellSize + this.cellSize / 2;
                const radius = this.cellSize / 4;
               
                // Draw end flower
                this.ctx.fillStyle = '#FFFFFF';
                this.ctx.beginPath();
                this.ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                this.ctx.fill();
               
                // Draw petals
                this.ctx.fillStyle = '#F06292';
                for (let i = 0; i < 8; i++) {
                    const angle = (i * Math.PI) / 4;
                    const petalX = centerX + Math.cos(angle) * radius * 1.4;
                    const petalY = centerY + Math.sin(angle) * radius * 1.4;
                    this.ctx.beginPath();
                    this.ctx.arc(petalX, petalY, radius * 0.7, 0, 2 * Math.PI);
                    this.ctx.fill();
                }
            }


            drawPlayerFlower(x, y) {
                const centerX = x * this.cellSize + this.cellSize / 2;
                const centerY = y * this.cellSize + this.cellSize / 2;
                const radius = this.cellSize / 2 - 2;
               
                // Draw player as a moving flower
                this.ctx.fillStyle = '#E91E63';
                this.ctx.beginPath();
                this.ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                this.ctx.fill();
               
                // Draw petals around player
                this.ctx.fillStyle = '#F8BBD9';
                for (let i = 0; i < 6; i++) {
                    const angle = (i * Math.PI) / 3;
                    const petalX = centerX + Math.cos(angle) * radius * 1.2;
                    const petalY = centerY + Math.sin(angle) * radius * 1.2;
                    this.ctx.beginPath();
                    this.ctx.arc(petalX, petalY, radius * 0.6, 0, 2 * Math.PI);
                    this.ctx.fill();
                }
               
                // Draw center
                this.ctx.fillStyle = '#FFFFFF';
                this.ctx.beginPath();
                this.ctx.arc(centerX, centerY, radius * 0.4, 0, 2 * Math.PI);
                this.ctx.fill();
            }


            movePlayer(direction) {
                const newX = this.player.x + direction.x;
                const newY = this.player.y + direction.y;
               
                // Check bounds and walls
                if (newX >= 0 && newX < this.maze[0].length &&
                    newY >= 0 && newY < this.maze.length &&
                    this.maze[newY][newX] === 0) {
                   
                    this.player.x = newX;
                    this.player.y = newY;
                    this.moves++;
                    this.updateStats();
                    this.drawMaze();
                   
                    // Check win condition
                    if (this.player.x === this.end.x && this.player.y === this.end.y) {
                        this.gameWin();
                    }
                }
            }


            updateStats() {
                document.getElementById('moves').textContent = this.moves;
            }


            startTimer() {
                this.startTime = Date.now();
                this.timerInterval = setInterval(() => {
                    if (!this.gamePaused) {
                        const elapsed = Date.now() - this.startTime;
                        const minutes = Math.floor(elapsed / 60000);
                        const seconds = Math.floor((elapsed % 60000) / 1000);
                        document.getElementById('timer').textContent =
                            `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                    }
                }, 1000);
            }


            stopTimer() {
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                    this.timerInterval = null;
                }
            }


            newGame() {
                this.stopTimer();
                this.gameRunning = true;
                this.gamePaused = false;
                this.moves = 0;
                this.startTime = null;
                document.getElementById('gameOver').style.display = 'none';
                this.generateMaze();
                this.startTimer();
                this.updateStats();
                
                // Start background music
                const bgMusic = document.getElementById('backgroundMusic');
                bgMusic.volume = 0.5; // Set volume to 50%
                bgMusic.currentTime = 0; // Reset to beginning
                bgMusic.play();
            }


            togglePause() {
                this.gamePaused = !this.gamePaused;
                const pauseBtn = document.getElementById('pauseBtn');
                const bgMusic = document.getElementById('backgroundMusic');
                
                if (this.gamePaused) {
                    pauseBtn.innerHTML = '<i class="fas fa-play"></i> Resume';
                    pauseBtn.className = 'btn btn-success';
                    bgMusic.pause(); // Pause background music
                } else {
                    pauseBtn.innerHTML = '<i class="fas fa-pause"></i> Pause';
                    pauseBtn.className = 'btn btn-warning';
                    if (this.gameRunning) {
                        bgMusic.play(); // Resume background music
                    }
                }
            }


            showHint() {
                // Simple hint: flash the exit briefly
                const originalColor = this.ctx.fillStyle;
                this.ctx.fillStyle = '#f1c40f';
                this.ctx.fillRect(
                    this.end.x * this.cellSize,
                    this.end.y * this.cellSize,
                    this.cellSize,
                    this.cellSize
                );
               
                setTimeout(() => {
                    this.drawMaze();
                }, 500);
            }


            gameWin() {
                this.gameRunning = false;
                this.stopTimer();
               
                const finalTime = document.getElementById('timer').textContent;
                document.getElementById('finalTime').textContent = finalTime;
                document.getElementById('finalMoves').textContent = this.moves;
                document.getElementById('finalLevel').textContent =
                    document.getElementById('level').textContent;
               
                // Stop background music and play victory sound
                const bgMusic = document.getElementById('backgroundMusic');
                const victorySound = document.getElementById('victorySound');
                bgMusic.pause();
                victorySound.currentTime = 0;
                victorySound.volume = 0.6;
                victorySound.play();
               
                // Show level-specific congratulations message
                this.showLevelCongratulations();
               
                document.getElementById('gameOver').style.display = 'flex';
            }


            showLevelCongratulations() {
                const gameOverTitle = document.getElementById('gameOverTitle');
                const gameOverContent = document.querySelector('.game-over-content');
               
                // Get level-specific congratulations message and Duluth fact
                const levelMessages = {
                    easy: {
                        congrats: 'üå∏ Congratulations! You completed the Easy level! üå∏',
                        fact: 'The deepest point in Lake Superior is 405 metres or 1,333 feet.'
                    },
                    medium: {
                        congrats: 'üå∏ Congratulations! You completed the Medium level! üå∏',
                        fact: 'Lake Superior Holds 10% of the Planet\'s Fresh Water'
                    },
                    hard: {
                        congrats: 'üå∏ Congratulations! You completed the Hard level! üå∏',
                        fact: 'The Duluth Lift Bridge didn\'t originally lift'
                    },
                    expert: {
                        congrats: 'üå∏ Congratulations! You completed the Expert level! üå∏',
                        fact: 'Beneath Duluth lies an extensive network of steam tunnels, originally built to house steam pipes.'
                    }
                };
               
                const currentLevel = this.difficulty;
                const message = levelMessages[currentLevel];
               
                // Update the congratulations title
                gameOverTitle.innerHTML = message.congrats;
               
                // Add or update the Duluth fact section
                let factElement = document.getElementById('duluthFact');
                if (!factElement) {
                    factElement = document.createElement('div');
                    factElement.id = 'duluthFact';
                    factElement.style.cssText = `
                        background: linear-gradient(145deg, #F8BBD9 0%, #E91E63 100%);
                        color: white;
                        padding: 15px;
                        border-radius: 10px;
                        margin: 15px 0;
                        font-weight: bold;
                        text-align: center;
                        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
                    `;
                   
                    // Insert the fact element after the congratulations paragraph
                    const congratsParagraph = gameOverContent.querySelector('p');
                    congratsParagraph.parentNode.insertBefore(factElement, congratsParagraph.nextSibling);
                }
               
                factElement.innerHTML = `üèõÔ∏è <strong>Duluth Fact:</strong> ${message.fact}`;
            }
        }


        // Initialize the game when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new MazeGame();
        });
    </script>
</body>
</html>